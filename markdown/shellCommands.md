<link rel="stylesheet" type="text/css" href="MD_styling.css" />

Fundamental Shell Concepts  
==========================  

Many Linux distros use *bash*, or *Bourne Again SHell*. Other common shells include *sh*, *ksh* and *csh*. *bash* conforms to the *IEEE POSIX Shell and Tools* specification. For passing the time when watching paint dry has become boring, run `man bash`. 

# Command Syntax

Most Linux commands will follow the same basic syntax when presenting output for viewing. Consider the following usage line:

~~~ bash
user@host:dir$ command -[o] [-r <param>] [-l <item1>[,item2,...]] thing && command2
~~~

The first part of the line givens some information about the logged in user. It displays the user name and the computer hostname. In most systems, *dir* represents the full path to the current working directory. `$` is the prompt terminator for a normal user; `#` terminates a prompt for a user with sudo privileges. Brackets "[ ]" represent optional arguments. Angled brackets "< >" represent required arguments. Some programs omit the "< >" as in the case of *thing* above.

> `-o`						:	optional argument. The program will choose a default value if it is not included.   
> `-r <param>`				:	optional argument. When using this option, a *param* is expected. The program will throw an error if no *param* is given.  
> `-l <item1>[,item2,...]]`	:	optional argument. This argument expects at least one *item* to be passed. However, additional items *may* be passed if separated by a ",".  
> `thing`					:	required argument. The program will fail if this argument is omitted.  
> `&&`						:	in this context, acts as a separator between two commands. `command2` will only execute if `command` exited without an error.

In most instances, single-character arguements (such as `-o`, `-r`, and `-l` above) will have a single "-" in front of them to denote an option. Multi-character arguments (such as `--option` and `--long-option`) use "--" as the option marker. Options can be mixed in multiple orders, and most can be used together. A semicolon `;` can be used to separate multiple commands on the same line. 

# Special Characters  

## Directory Characters

Some sequences provide shortcuts to commonly used directories.

> `./`	:	represents the path to the current directory. In a shell, instructs the shell to look in the current directory.  
> `~`	:	represents the path to the active user's home directory, i.e. */home/user/*.  
> `/`	:	represents the path to the root directory. Any location on the system can be found by starting at *root*.  
> `..`	:	represents the path to the parent directory. 

## Dot Character

> `.`	:	changes meaning depending on the context. At the start of a file name, the "." tells the OS to create a hidden file. The other meaning sources a command and then executes.   

In most circumstances, executing a script in a shell creates a sub-shell in which to run that command. Practically, this means that any shell environment changes caused by the program end when the script ends. The `. ./command` (notice the " ") or `source ./command` syntax causes a script to run in the current environment. Any environment changes that occur due to the script reflect in the current shell environment, even after the script dies. This is often done after editing the *~/.bashrc* file to update the environment to current changes.

## Redirectors

Every process starts with 3 *file descriptors*, indexed starting at 0. `stdin` is the stream for input to a program, with an FD of 0; `stdout` is the output stream of a program, and has an FD of 1; `stderr` reports errors generated by a program, and has FD 2. These and other file descriptors can be redirected to different locations.

> `>`	:	angled bracket, greater than. Redirects the output of the left side to the input of the right side. If the file on the right does not exist, it will be created. If it does exist, it will be overwritten with new data.  
> `>>`	:	same as above, except data will be appended to the end of the file if it already exists instead of overwriting it.  
> `2>&1`:	redirects `stderr` to `stdout`. Often used to redirect program output to a single location, or to silence output.  
> `<`	:	angled bracket, less than. redirects the output from the right side to stdin on the left side.  
> `|`	:	pipe character. redirects `stdout` of the left side to `stdin` of the right side.

# Covered Commands

# Getting Help

For many commands in the Linux world, a `-h` or `--help` option will give a program overview and summary insight on how to use it. For more in-depth information, `man` and `info` exist. For getting pointed in the right direction, use `apropos`. 

> `man <command>`	:	displays the documentation for a given command. If an item does not have an entry, then check the spelling of the command. Use `tab` completion (tapping the `tab` key) after a few characters to receive suggestions.   
> `info <command>`	:	displays additional documentation for a given command.  
> `apropos <string>`:	searches through the documentation for a given string. It can often provide the item for the `man` command. 

# Listing Files

To discover files in a directory, use the `ls` command. A simple mnemonic for remembering: *list stuff*. To list only files matching a particular pattern, pass a regular expression (regex) as an argument.

> `ls`		:	displays the contents of a directory in a grid  
> `ls -lh`	:	displays the contents in a more detailed manner  
> `ls -G`	:	color-codes the output according to file types  
> `ls [regex]:	list only files that match a given pattern.

# Changing Directories  

To view the current directory, use `pwd`. Use `cd` to Change Directory into a different folder. You must have read+execute permissions in order to move into a directory.

> `cd -`	:	move back to the previous directory  
> `cd ~`	:	move to the current user's *home* folder

# Making Directories

To create a new directory, use `mkdir <dirname>`.

# Copying Files

Use `cp <src> <dest>` to copy a from *src* to *dest*.  

> `cp -r <src> <dest>`	:	recursively copies a directory to another directory  
> `cp -v <src> <dest>`	:	be verbose when copying

# Deleting Files

Deleting files is generally referred to as removing files. For this reason, `rm <file>` says "remove \<file\>". Like `ls`, `rm` accepts regexs in order to determine which files to remove.

> `rm -r <directory>`	:	removes all files from a given directory, including the directory itself  
> `rm -ri <directory>`	:	recursively remove the directory, prompting for each file name  

# Moving Files

Use `mv <src>[ src2 src3...] <dest>` to move files or a list of files from one location to another. Regexes can provide a pattern of files to match when moving. When specifying multiple files, the destination must be a directory.

> `mv <old name> <new name>`	:	renames a file  
> `mv -u <src>[ src2...] <dest>`:	moves the files into the destination only if the source file is newer than the destination file

# Setting File Permissions

There are three groups of file permission in Linux: owner, group, and everyone else. Each of these groups may have a different set of *RWX* permissions. The numbers for each permission come from the binary representation based on its position.

> **r**	:	read permissions. This grants access to read from a given file. In the case of a directory, this allows a user to view the contents of the directory. The number for this permission is 4 because 2^2 = 4.  
> **w**	:	write permissions. This grants permission to write to a file. For directories, a user may create new files. The number for this permission is 2 because 2^1 = 1.  
> **x**	:	execute permissions. This grants permission to execute a file. This permission allows a user to execute a program within a directory. The number for this permission is 1 because 2^0 = 1.  

Often, the permission can be viewed as a sum of the permissions for a permissions group. For a group of permissions, the sum of these numbers tells the user which permissions exist for a file. The leftmost column of `ls -lh` represents the permissions for a file in the order *owner:group:other*. Alternatively, `stat <file>` will also provide detailed file information.

To set permissions on a file, use `chmod <perms> file[ file2...]`.

> `chmod 755 <file>`	:	sets the permissions on a file to RWX R-X R-X
> `chmod u+x <file>`	:	allows the owner to execute the file. Any other permissions do not change.  
> `chmod g+r <file>`	:	allows users in the same group as the group on the file to read it. Other permissions do not change.  
> `chmod o-rw <file>`	:	removes read and write permissions from *other*. Other permissions do not change.

Additional permission information resides in the User section of the course.

# Finding a File

Linux uses `find <path> <expression>` to find files in non-indexed locations. Tests are treated in linear fashing from left to right.

> `find ./ -name "*.py"`:	finds the files with a *.py* extension in the current directory and all subdirectories  
> `find / -perm 755`	:	finds all files with permissions set to 755, or RWX R-W R-W.  
> `find ./ -perm /u=s`	:	finds all files in the current directory and subdirectories with the SUID bit set.

Another option for finding files is `locate <pattern>[ pattern..]`. This command uses a database (usually at */var/lib/mlocate/mlocate.db*) in order to increase the speed at which files are found. The database is scheduled to update daily by `cron` in most cases. Use `updatedb` to update the list of files in the database.

> `locate -e <pattern>`	:	check to make sure the file still exists before printing it.  
> `locate -i <pattern>`	:	perform a case insensitive search.  
> `locate -d [path] <pattern>`	:	perform a search using the databasae at *path*. The default database is used if *path* is blank. Multiple databases can be strung together in this way.  

# Viewing File Contents

Three commands allowing viewing contents: `cat`, `more`, and `less`. `cat` simply outputs the contents of a file to the terminal, and may overflow the screen size for longer files. The other two commands allow scrolling through the contents of the file.

> `cat <file>`	:	prints a file to the screen. This command works well for shorter files. It more often occurs in scripts in which the contents of a file are need for another command.  
> `more <file>`	:	should be deprecated in favor of `less`. However, not all systems have `less`. This command allows scrolling through a file in a single direction.  
> `less <file>`	:	allows a user to scroll through a file bidirectionally. Also implements searching functions and several enhancements over `more`. It does not require reading an entire file before displaying output to the screen; this allows more efficient memory usage and a faster startup time.  
> `head [-n #] <file>`	:	displays the first *n* lines of a file (default is 10). `-n` changes the number of lines displayed.  
> `tail [-n #] <file>`	:	displays the last *n* lines of a file (default is 10). `-n` changes the number of lines displayed.  

# Searching for a String

To find a string in a an input sequence, use `grep <pattern> [file]`. `grep` provides a very in-depth searching mechanism for going through input. In the case of a binary file, `strings <file>` can be used to extract printable data from the file. Very often, data is piped to `grep` in order to search through it. 

> `grep -i <pattern>`	:	perform a case-insensitive search for the *pattern*. By default. `grep` is case-sensitive.  
> `grep -v <pattern>`	:	invert the match. Anything that does NOT match *pattern* will be marked.  
> `grep -c <pattern>`	:	count the number of lines, but do not print any other information.  

# Creating a File

There are many ways to create a new file. This course is not a comparison of the various text editors. There is a module devoted to *Vi/VIM* so that users will have some knowledge of how to edit text files in a Linux system.

> `vi <file>`		:	a CLI text editor that is found on most distros.  
> `vim <file>`		:	Vi iMproved. A more feature rich CLI text editor found on almost as many distros.  
> `nano <file>`		:	a CLI text editor found on many distros.  
> `emacs <file>`	:	a CLI text editor found on many distros.  
> `touch <file>`	:	creates a new, empty file.  
> `echo <string> > <file>`:	creates a new file whose contents match *string*.  

Source: gnu.org  
		github.com/LinuxAtDuke/Intro-To-Linux
